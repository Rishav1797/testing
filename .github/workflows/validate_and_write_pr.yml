name: Validate PR & Preview input.json (with check run)

on:
  pull_request_target:
    types: [opened, edited, reopened, closed]

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

jobs:
  validate-preview-write:
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR body fields, post preview, create check run, write file on merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const REQUIRED_LABELS = [
              "Channels:",
              "Headless:",
              "Business Issue:",
              "Crew Name:",
              "Product Owner Name:",
              "Product Owner Email:",
              "Tech Lead Name:",
              "Tech Lead Email:",
              "Crew Lead Name:",
              "Crew Lead Email:",
              "Team Distribution List Email:",
              "Commando Brief:",
              "Comments:",
              "SPG:"
            ];

            const pr = context.payload.pull_request;
            const bodyRaw = pr?.body || "";
            const action = context.payload.action;
            const merged = pr?.merged;
            const checkName = "PR Template Validation";

            // Normalize and strip obvious markdown
            const body = bodyRaw
              .replace(/\*\*/g, "")
              .replace(/[_>`~-]/g, "")
              .replace(/\r\n/g, "\n")
              .trim();

            const lines = body.split("\n");
            const result = {};
            const missing = [];

            // Parse labels robustly (prevents bleed-over)
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              const labelMatch = REQUIRED_LABELS.find(label =>
                line.toLowerCase().startsWith(label.toLowerCase())
              );

              if (labelMatch) {
                let value = line.substring(labelMatch.length).trim();

                // If no inline value, look ahead a few lines for a value that is not a label
                if (!value) {
                  let j = i + 1;
                  while (j < lines.length && !lines[j].trim().match(/^[A-Z][A-Za-z ]*:/)) {
                    if (lines[j].trim()) {
                      value = lines[j].trim();
                      break;
                    }
                    j++;
                  }
                }

                // cleanup
                value = value.replace(/[*_`>~-]/g, "").replace(/\s+/g, " ").trim();

                // Prevent label bleed (value starting with another label)
                for (const lbl of REQUIRED_LABELS) {
                  if (value.toLowerCase().startsWith(lbl.toLowerCase()) && value.toLowerCase() !== "na") {
                    value = "";
                  }
                }

                // Accept NA, but reject empty
                if (!value) {
                  missing.push(labelMatch.replace(/:$/, ""));
                } else {
                  result[labelMatch.replace(/:$/, "")] = value;
                }
              }
            }

            // include uploaded template image path for preview (your uploaded file path)
            result["TemplateImageUrl"] = "/mnt/data/IMG-20251125-WA0000.jpg";

            const jsonContent = JSON.stringify(result, null, 2);

            // Helper: create a check run with summary + text and conclusion
            async function createCheckRun(conclusion, summary, text) {
              await github.rest.checks.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                name: checkName,
                head_sha: pr.head.sha,
                status: "completed",
                conclusion: conclusion,
                output: {
                  title: checkName,
                  summary: summary,
                  text: text
                }
              });
            }

            // If not merged: validate and post preview or failure
            if (!merged) {
              if (missing.length > 0) {
                const missingListText = missing.map(m => `- ${m}`).join("\n");
                const commentBody = [
                  "âš ï¸ **PR validation failed**",
                  "",
                  "**Missing (empty) fields:**",
                  missingListText,
                  "",
                  "Please fill all fields (use `NA` if not applicable). After updating the PR description this check will re-run automatically."
                ].join("\n");

                // Post comment on PR
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });

                // Create a failed check run so the Checks tab shows the reason
                const summary = `Validation failed: ${missing.length} missing field(s).`;
                const text = `Missing fields:\n${missingListText}`;
                await createCheckRun("failure", summary, text);

                // fail the workflow step
                throw new Error("Validation failed â€” missing fields: " + missing.join(", "));
              }

              // All good â€” create a preview comment and a successful check run
              const preview = "ðŸ§¾ **input.json preview:**\n```json\n" + jsonContent + "\n```\nâœ… All fields validated (NA accepted).";
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: preview
              });

              const summary = "Validation succeeded: all required fields present (NA accepted).";
              const text = "Preview posted to PR comment.";
              await createCheckRun("success", summary, text);

              console.log("Preview posted and check run success created.");
              return;
            }

            // If merged and action === closed -> write file to repo
            if (merged && action === "closed") {
              const path = "file/input.json";
              const message = `Add/update ${path} from PR #${context.issue.number} by ${context.actor}`;

              let sha;
              try {
                const res = await github.rest.repos.getContent({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path
                });
                sha = res.data.sha;
              } catch {}

              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path,
                message,
                content: Buffer.from(jsonContent).toString("base64"),
                sha
              });

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: "âœ… PR merged â€” `file/input.json` created/updated successfully."
              });

              // final check run indicating commit done
              await createCheckRun("success", "Committed file/input.json after merge", "File created/updated.");
            }
