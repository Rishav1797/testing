name: Validate PR & Commit input.json to PR branch

on:
  pull_request_target:
    types: [opened, edited, reopened, synchronize]

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

jobs:
  validate-and-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR fields and commit input.json
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const REQUIRED_LABELS = [
              "Channels:",
              "Headless:",
              "Business Issue:",
              "Crew Name:",
              "Product Owner Name:",
              "Product Owner Email:",
              "Tech Lead Name:",
              "Tech Lead Email:",
              "Crew Lead Name:",
              "Crew Lead Email:",
              "Team Distribution List Email:",
              "Commando Brief:",
              "Comments:",
              "SPG:"
            ];

            const pr = context.payload.pull_request;
            const bodyRaw = pr?.body || "";
            const headBranch = pr.head.ref;
            const headSha = pr.head.sha;
            const repo = context.repo.repo;
            const owner = context.repo.owner;

            // Clean markdown and normalize
            const body = bodyRaw
              .replace(/\*\*/g, "")
              .replace(/[_>`~-]/g, "")
              .replace(/\r\n/g, "\n")
              .trim();

            const lines = body.split("\n");
            const result = {};
            const missing = [];

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              const label = REQUIRED_LABELS.find(l =>
                line.toLowerCase().startsWith(l.toLowerCase())
              );
              if (!label) continue;

              let value = line.substring(label.length).trim();

              // Look ahead for multi-line values
              if (!value) {
                let j = i + 1;
                while (j < lines.length && !lines[j].trim().match(/^[A-Z][A-Za-z ]*:/)) {
                  if (lines[j].trim()) {
                    value = lines[j].trim();
                    break;
                  }
                  j++;
                }
              }

              value = value.replace(/[*_`>~-]/g, "").replace(/\s+/g, " ").trim();

              // Avoid label bleed
              for (const l2 of REQUIRED_LABELS) {
                if (value.toLowerCase().startsWith(l2.toLowerCase()) && value.toLowerCase() !== "na") {
                  value = "";
                }
              }

              const isEmpty = !value;
              const isNA = /^NA$/i.test(value);

              if (isEmpty) missing.push(label);
              else result[label.replace(/:$/, "")] = value;
            }

            if (missing.length > 0) {
              const msg = [
                "⚠️ **PR validation failed**",
                "",
                "**Missing (empty) fields:**",
                ...missing.map(f => `- ${f}`),
                "",
                "Please fill all fields (use `NA` if not applicable)."
              ].join("\n");

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr.number,
                body: msg
              });

              await github.rest.checks.create({
                owner,
                repo,
                name: "PR Template Validation",
                head_sha: headSha,
                status: "completed",
                conclusion: "failure",
                output: {
                  title: "Validation failed",
                  summary: `Missing ${missing.length} field(s)`,
                  text: missing.join(", ")
                }
              });

              throw new Error("Validation failed — missing fields");
            }

            // Include uploaded image reference
            result["TemplateImageUrl"] = "/mnt/data/IMG-20251125-WA0000.jpg";

            const jsonContent = JSON.stringify(result, null, 2);
            const path = "file/input.json";
            const message = `Auto-generate ${path} for PR #${pr.number}`;

            // Get file SHA if already exists in branch
            let sha;
            try {
              const res = await github.rest.repos.getContent({
                owner,
                repo,
                path,
                ref: headBranch
              });
              sha = res.data.sha;
            } catch {}

            // Commit directly to PR branch
            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path,
              message,
              content: Buffer.from(jsonContent).toString("base64"),
              sha,
              branch: headBranch
            });

            await github.rest.checks.create({
              owner,
              repo,
              name: "PR Template Validation",
              head_sha: headSha,
              status: "completed",
              conclusion: "success",
              output: {
                title: "Validation succeeded",
                summary: "All required fields filled (NA accepted).",
                text: `Committed ${path} to branch ${headBranch}`
              }
            });

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pr.number,
              body: `✅ Validation passed. \`${path}\` has been committed to **${headBranch}** and will appear under *Files changed*.`
            });
