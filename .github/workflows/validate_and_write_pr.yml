name: Validate PR & Commit input.json to appropriate businessConfig dirs

on:
  pull_request_target:
    types: [opened, edited, reopened, synchronize, closed]

permissions:
  contents: write
  issues: write
  pull-requests: write
  checks: write

jobs:
  validate-and-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR fields and commit input.json(s)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // ---------------------------
            // Config
            // ---------------------------
            const REQUIRED_LABELS = [
              "Channels:",
              "Headless:",
              "Business Issue:",
              "Crew Name:",
              "Product Owner Name:",
              "Product Owner Email:",
              "Tech Lead Name:",
              "Tech Lead Email:",
              "Crew Lead Name:",
              "Crew Lead Email:",
              "Team Distribution List Email:",
              "Commando Brief:",
              "Comments:",
              "SPG:"
            ];
            const checkName = "PR Template Validation";
            const templateImagePath = "/mnt/data/IMG-20251125-WA0000.jpg"; // from your upload
            // ---------------------------

            const pr = context.payload.pull_request;
            if (!pr) throw new Error("No pull request found in context.");

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headBranch = pr.head.ref;
            const headSha = pr.head.sha;
            const prNumber = pr.number;
            const action = context.payload.action;

            // Get the list of changed files
            const filesResp = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number: prNumber,
              per_page: 300
            });

            // Collect target directories (businessConfig/<X>)
            const targets = new Set();
            for (const f of filesResp.data) {
              const p = f.filename;
              const segs = p.split("/");
              if (segs.length >= 2 && segs[0] === "businessConfig") {
                targets.add(`businessConfig/${segs[1]}`);
              }
            }

            // ✅ Skip workflow entirely if nothing under businessConfig/
            if (targets.size === 0) {
              console.log("No files under businessConfig/ — skipping validation and commit.");
              await github.rest.checks.create({
                owner,
                repo,
                name: checkName,
                head_sha: headSha,
                status: "completed",
                conclusion: "success",
                output: {
                  title: "Skipped validation",
                  summary: "No files under businessConfig/, skipping validation and file creation.",
                  text: "This PR does not touch any businessConfig/ paths. No input.json created."
                }
              });
              return;
            }

            // Normalize PR body
            const bodyRaw = pr.body || "";
            const body = bodyRaw
              .replace(/\*\*/g, "")
              .replace(/[_>`~-]/g, "")
              .replace(/\r\n/g, "\n")
              .trim();

            const lines = body.split("\n");
            const result = {};
            const missing = [];

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i].trim();
              const labelMatch = REQUIRED_LABELS.find(label =>
                line.toLowerCase().startsWith(label.toLowerCase())
              );
              if (!labelMatch) continue;

              let value = line.substring(labelMatch.length).trim();
              if (!value) {
                let j = i + 1;
                while (j < lines.length && !lines[j].trim().match(/^[A-Z][A-Za-z ]*:/)) {
                  if (lines[j].trim()) {
                    value = lines[j].trim();
                    break;
                  }
                  j++;
                }
              }

              value = value.replace(/[*_`>~-]/g, "").replace(/\s+/g, " ").trim();
              for (const lbl of REQUIRED_LABELS) {
                if (value.toLowerCase().startsWith(lbl.toLowerCase()) && value.toLowerCase() !== "na") {
                  value = "";
                }
              }

              const isEmpty = !value;
              const isNA = /^NA$/i.test(value);
              if (isEmpty) missing.push(labelMatch.replace(/:$/, ""));
              else result[labelMatch.replace(/:$/, "")] = value;
            }

            // If validation failed → fail the check and stop
            if (missing.length > 0) {
              const missingList = missing.map(m => `- ${m}`).join("\n");
              const commentBody = [
                "⚠️ **PR validation failed**",
                "",
                "**Missing (empty) fields:**",
                missingList,
                "",
                "Please fill all fields (use `NA` if not applicable)."
              ].join("\n");

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: commentBody
              });

              await github.rest.checks.create({
                owner,
                repo,
                name: checkName,
                head_sha: headSha,
                status: "completed",
                conclusion: "failure",
                output: {
                  title: "Validation failed",
                  summary: `Missing ${missing.length} field(s).`,
                  text: `Missing:\n${missingList}`
                }
              });

              throw new Error("Validation failed — missing fields: " + missing.join(", "));
            }

            // Add image path and prepare JSON
            result["TemplateImageUrl"] = templateImagePath;
            const jsonContent = JSON.stringify(result, null, 2);

            // Commit to each detected businessConfig/<X> folder
            const createdPaths = [];
            for (const target of Array.from(targets)) {
              const filePath = `${target}/input.json`;
              const message = `Auto-generate ${filePath} for PR #${prNumber}`;

              let sha;
              try {
                const res = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: filePath,
                  ref: headBranch
                });
                sha = res.data.sha;
              } catch {}

              await github.rest.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: filePath,
                message,
                content: Buffer.from(jsonContent).toString("base64"),
                sha,
                branch: headBranch
              });

              createdPaths.push(filePath);
            }

            await github.rest.checks.create({
              owner,
              repo,
              name: checkName,
              head_sha: headSha,
              status: "completed",
              conclusion: "success",
              output: {
                title: "Validation succeeded",
                summary: `Created ${createdPaths.length} file(s).`,
                text: `Committed to branch ${headBranch}:\n${createdPaths.map(p => `- ${p}`).join("\n")}`
              }
            });

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `✅ Validation passed. Committed file(s):\n${createdPaths.map(p => `- ${p}`).join("\n")}`
            });

            console.log("Committed:", createdPaths);
